import os
import zipfile
import subprocess
import threading
import shutil
from math import sin, cos, radians
from kivy.app import App
from kivy.uix.boxlayout import BoxLayout
from kivy.uix.label import Label
from kivy.uix.button import Button
from kivy.uix.scrollview import ScrollView
from kivy.uix.popup import Popup
from kivy.uix.filechooser import FileChooserListView
from kivy.uix.treeview import TreeView, TreeViewLabel
from kivy.graphics import Color, Rectangle
from kivy.core.window import Window
from kivy.clock import Clock


Window.clearcolor = (0.05, 0.05, 0.05, 1)

TARGET_LIBS = [
    "libUE4.so", "libanogs.so", "libTDataMaster.so", "libgcloud.so", "libanort.so"
]

PUBG_KEYWORDS = {
    "aimbot": 100, "cheat": 100, "esp": 95, "wallhack": 90, "hook": 85, "inject": 80,
    "memory": 75, "bypass": 70, "root": 65, "modmenu": 60, "mod": 55,
    "patch": 45, "libue4": 40, "libanogs": 35, "libTDataMaster": 35,
    "libtersafe": 30, "unpack": 25, "damage": 20, "speed": 15,
    "vehicle": 10, "anticheat": 85
}

def get_color(score):
    if score >= 80:
        return (1, 0.2, 0.2, 1)
    elif score >= 50:
        return (1, 0.7, 0.2, 1)
    else:
        return (0.3, 1, 0.3, 1)

class OffsetVortex(BoxLayout):
    def __init__(self, **kwargs):
        size_hint = kwargs.pop('size_hint', (0.3, 1))
        super().__init__(size_hint=size_hint, **kwargs)
        with self.canvas:
            Color(0.0, 0.7, 1, 0.15)
            self.rect = Rectangle(size=self.size, pos=self.pos)
        self.bind(pos=self._update_rect, size=self._update_rect)
        self.angles = [i * 45 for i in range(8)]
        Clock.schedule_interval(self.rotate, 0.04)

    def _update_rect(self, *args):
        self.rect.pos = self.pos
        self.rect.size = self.size

    def rotate(self, dt):
        self.canvas.clear()
        with self.canvas:
            Color(0.0, 0.7, 1, 0.4)
            cx, cy = self.center
            radius = min(self.width, self.height) / 3
            self.angles = [(angle + 5) % 360 for angle in self.angles]
            for angle in self.angles:
                x = cx + radius * cos(radians(angle))
                y = cy + radius * sin(radians(angle))
                Color(0.0, 0.7, 1, 0.6)
                size = 12
                Rectangle(pos=(x - size/2, y - size/2), size=(size, size))

class BashaUI(BoxLayout):
    def __init__(self, **kwargs):
        super().__init__(orientation='horizontal', spacing=12, padding=15, **kwargs)
        with self.canvas.before:
            Color(0.02, 0.02, 0.02, 1)
            self.bg = Rectangle(size=self.size, pos=self.pos)
        self.bind(size=self._update_bg, pos=self._update_bg)

        left_panel = BoxLayout(orientation='vertical', size_hint=(0.7, 1), spacing=8)

        self.title = Label(text="[b][color=00FF99]BASHA - RIP  BYPASS[/color][/b]",
                           markup=True, font_size=24, size_hint=(1, None), height=50)
        left_panel.add_widget(self.title)

        btns = BoxLayout(size_hint=(1, None), height=48, spacing=15)
        btn_style = {'background_normal': '', 'background_color': (0.07, 0.25, 0.3, 1), 'color': (1, 1, 1, 1), 'font_size': 16, 'bold': True}

        self.btn_select = Button(text="Select APK", **btn_style)
        self.btn_select.bind(on_press=self.choose_apk)
        btns.add_widget(self.btn_select)

        self.btn_analyze = Button(text="START", **btn_style)
        self.btn_analyze.bind(on_press=self.start_analysis)
        btns.add_widget(self.btn_analyze)

        self.btn_report = Button(text="Save Report", **btn_style)
        self.btn_report.bind(on_press=self.save_report)
        btns.add_widget(self.btn_report)

        self.btn_patch = Button(text="Generate Patch", **btn_style)
        self.btn_patch.bind(on_press=self.save_patch)
        btns.add_widget(self.btn_patch)

        left_panel.add_widget(btns)

        self.tree_view = TreeView(hide_root=True, indent_level=30, size_hint=(1, 1))
        self.scroll_area = ScrollView()
        self.scroll_area.add_widget(self.tree_view)
        left_panel.add_widget(self.scroll_area)

        self.status = Label(text="[color=00ff00]Ready[/color]", markup=True, size_hint=(1, None), height=28)
        left_panel.add_widget(self.status)

        self.right_panel = OffsetVortex(size_hint=(0.3, 1))

        self.add_widget(left_panel)
        self.add_widget(self.right_panel)

        self.apk_path = ""
        self.output_dir = ""
        self.results = {}

    def _update_bg(self, *args):
        self.bg.size = self.size
        self.bg.pos = self.pos

    def choose_apk(self, instance):
        chooser = FileChooserListView(path=os.path.expanduser("~"), filters=["*.apk"])
        popup = Popup(title="Select APK File", content=chooser, size_hint=(0.9, 0.9))

        def on_select(_, selection, __):
            if selection:
                self.apk_path = selection[0]
                self.output_dir = os.path.join(os.path.dirname(self.apk_path), "BASHA-RIP")
                self.update_status(f"APK selected: {os.path.basename(self.apk_path)}")
                self.tree_view.clear_widgets()
                self.results.clear()
                popup.dismiss()

        chooser.bind(on_submit=on_select)
        popup.open()

    def start_analysis(self, instance):
        if not self.apk_path:
            self.update_status("Please select an APK file first!", color="ff5555")
            return
        threading.Thread(target=self.analyze_apk, daemon=True).start()

    def analyze_apk(self):
        shutil.rmtree(self.output_dir, ignore_errors=True)
        os.makedirs(self.output_dir, exist_ok=True)
        self.results.clear()
        Clock.schedule_once(lambda dt: self.tree_view.clear_widgets())

        try:
            with zipfile.ZipFile(self.apk_path, 'r') as zip_ref:
                for file in zip_ref.namelist():
                    if file.startswith("lib/") and any(lib in file for lib in TARGET_LIBS):
                        zip_ref.extract(file, self.output_dir)
            Clock.schedule_once(lambda dt: self.update_status("APK extracted successfully"))
        except Exception as e:
            Clock.schedule_once(lambda dt: self.update_status(f"Extraction failed: {e}", color="ff4444"))
            return

        total_threats = 0

        for root, _, files in os.walk(self.output_dir):
            for file in files:
                if file.endswith(".so"):
                    full_path = os.path.join(root, file)
                    try:
                        result = subprocess.run(["strings", "-tx", full_path], capture_output=True, text=True)
                        for line in result.stdout.splitlines():
                            parts = line.strip().split(maxsplit=1)
                            if len(parts) < 2:
                                continue
                            offset, text = parts
                            for kw, score in PUBG_KEYWORDS.items():
                                if kw in text.lower():
                                    if file not in self.results:
                                        self.results[file] = []
                                    self.results[file].append((int(offset, 16), kw, score))
                                    total_threats += 1
                    except Exception as e:
                        Clock.schedule_once(lambda dt: self.update_status(f"Scan error: {e}", color="ff4444"))

        def show_tree(dt):
            self.tree_view.clear_widgets()
            for file, entries in self.results.items():
                parent_node = self.tree_view.add_node(TreeViewLabel(text=f"[b]{file}[/b]", markup=True))
                for offset, kw, score in entries:
                    color = get_color(score)
                    hex_color = ''.join(f'{int(c*255):02X}' for c in color[:3])
                    label_text = f"[color=#{hex_color}]{kw.upper()} @ 0x{offset:X} (Score: {score})[/color]"
                    self.tree_view.add_node(TreeViewLabel(text=label_text, markup=True), parent_node)
            self.update_status(f"Analysis complete: {total_threats} threat(s) found")

        Clock.schedule_once(show_tree)

    def save_report(self, instance):
        if not self.results:
            self.update_status("No results to save", color="ff4444")
            return
        report_path = os.path.join(self.output_dir, "report.txt")
        try:
            with open(report_path, "w", encoding="utf-8") as f:
                f.write("=== BASHA MOD Report ===\n\n")
                for file, entries in self.results.items():
                    for offset, kw, score in entries:
                        f.write(f"{file} | 0x{offset:X} | {kw.upper()} | Threat Score: {score}\n")
            self.update_status(f"Report saved to {report_path}")
        except Exception as e:
            self.update_status(f"Failed to save report: {e}", color="ff4444")

    def save_patch(self, instance):
        if not self.results:
            self.update_status("No patchable entries found", color="ff4444")
            return
        patch_path = os.path.join(self.output_dir, "patch.sub")
        try:
            with open(patch_path, "w", encoding="utf-8") as f:
                f.write("// Patch script generated by BASHA - @MODBASHA\n")
                for file, entries in self.results.items():
                    for offset, kw, score in entries:
                        f.write(f'MemoryPatch::createWithHex("{file}", 0x{offset:X}, "90 90 90 90").Modify(); // {kw.upper()}\n')
            self.update_status(f"Patch script saved to {patch_path}")
        except Exception as e:
            self.update_status(f"Failed to save patch: {e}", color="ff4444")

    def update_status(self, message, color="00ff00"):
        self.status.text = f"[color={color}]{message}[/color]"


class BashaApp(App):
    def build(self):
        return BashaUI()


if __name__ == "__main__":
    BashaApp().run()
